//------------------------------------------------------------------------------
// <auto-generated>
// CleanArchitecture.Blazor - MIT Licensed.
// Author: neozhu
// CreatedAt/Modified: 2025-03-19
// Handles LoginAuditCreatedEvent: triggered when a new contact is created.
// Extendable for additional actions (e.g., notifications, system updates).
// </auto-generated>
//------------------------------------------------------------------------------

using CleanArchitecture.Blazor.Application.Common.Interfaces;
using CleanArchitecture.Blazor.Domain.Enums;
using CleanArchitecture.Blazor.Domain.Identity;
using DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing;
using MaxMind.GeoIP2;
using Microsoft.Extensions.DependencyInjection;
using ZiggyCreatures.Caching.Fusion;

namespace CleanArchitecture.Blazor.Application.Features.LoginAudits.EventHandlers;

public class LoginAuditCreatedEventHandler : INotificationHandler<LoginAuditCreatedEvent>
{

    private readonly IServiceScopeFactory _scopeFactory;

    private readonly ILogger<LoginAuditCreatedEventHandler> _logger;
    private readonly ISecurityAnalysisService _securityAnalysisService;

    public LoginAuditCreatedEventHandler(
        IServiceScopeFactory scopeFactory,
        ILogger<LoginAuditCreatedEventHandler> logger,
        ISecurityAnalysisService securityAnalysisService)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
        _securityAnalysisService = securityAnalysisService;
    }

    public async Task Handle(LoginAuditCreatedEvent notification, CancellationToken cancellationToken)
    {
        if (!string.IsNullOrEmpty(notification.Item.IpAddress) && !notification.Item.IpAddress.StartsWith("127") && string.IsNullOrEmpty(notification.Item.Region))
        {
            try
            {
                using (var scope = _scopeFactory.CreateScope())
                {
                    using (var client = scope.ServiceProvider.GetRequiredService<WebServiceClient>())
                    {
                        var geolocation = await client.CityAsync(notification.Item.IpAddress);
                        if (geolocation != null)
                        {
                            var regionParts = new List<string>();

                            if (!string.IsNullOrEmpty(geolocation.City.Name))
                                regionParts.Add(geolocation.City.Name);

                            if (geolocation.Subdivisions.Any())
                                regionParts.Add(geolocation.Subdivisions.FirstOrDefault().Name);

                            if (!string.IsNullOrEmpty(geolocation.Country.Name))
                                regionParts.Add(geolocation.Country.Name);


                            var region = regionParts.Count > 0 ? string.Join(", ", regionParts) : null;


                            var dbContextFactory = scope.ServiceProvider.GetRequiredService<IApplicationDbContextFactory>();
                            await using var db = await dbContextFactory.CreateAsync(cancellationToken);
                            await db.LoginAudits.Where(x => x.Id == notification.Item.Id).ExecuteUpdateAsync(x => x.SetProperty(y => y.Region, region));

                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get geolocation for IP: {IpAddress}", notification.Item.IpAddress);
            }
        }

        // Analyze account security using the dedicated service in a new scope
        using (var scope = _scopeFactory.CreateScope())
        {
            var securityAnalysisService = scope.ServiceProvider.GetRequiredService<ISecurityAnalysisService>();
            await securityAnalysisService.AnalyzeUserSecurityAsync(notification.Item, cancellationToken);
        }
    }
}
