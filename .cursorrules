# Clean Architecture Blazor Server Rules

## 🏗️ **ARCHITECTURE PRINCIPLES**

### **Layer Dependency Rules** (CRITICAL - NEVER VIOLATE)
```
✅ ALLOWED DEPENDENCIES:
UI → Application → Domain
Infrastructure → Application → Domain

❌ FORBIDDEN DEPENDENCIES:
Application → Infrastructure
Application → UI  
Domain → Application
Domain → Infrastructure
Domain → UI
UI → Infrastructure (except Program.cs DI setup)
```

### **Project Structure**
```
src/
├── Domain/           # Core business entities, no dependencies
├── Application/      # Business logic, interfaces, DTOs
├── Infrastructure/   # External concerns, implements Application interfaces
└── Server.UI/        # Blazor Server UI, depends only on Application
```

## 📋 **CODING STANDARDS**

### **Service Implementation Rules**
1. **ALWAYS create interfaces in Application layer first**
   ```csharp
   // ✅ Application/Common/Interfaces/IYourService.cs
   public interface IYourService
   {
       Task<Result<T>> DoSomethingAsync(RequestDto request);
   }
   
   // ✅ Infrastructure/Services/YourService.cs  
   public class YourService : IYourService
   {
       // Implementation
   }
   ```

2. **NEVER implement services directly in UI layer without interfaces**
   ```csharp
   // ❌ WRONG - Direct implementation in UI
   public class SomeUIService 
   
   // ✅ CORRECT - Interface first
   public interface ISomeUIService  // in Application
   public class SomeUIService : ISomeUIService  // in UI
   ```

### **Data Access Rules**
1. **ALWAYS use CQRS pattern for data operations**
   ```csharp
   // ✅ CORRECT - Use Mediator
   var result = await Mediator.Send(new GetUsersQuery());
   
   // ❌ WRONG - Direct DbContext access in UI
   @inject ApplicationDbContext Context
   var users = await Context.Users.ToListAsync();
   ```

2. **NEVER inherit from DbContext in UI components**
   ```csharp
   // ❌ WRONG
   @inherits OwningComponentBase<ApplicationDbContext>
   
   // ✅ CORRECT
   @inject IMediator Mediator
   ```

### **Configuration Management Rules**
1. **ALWAYS use IOptions pattern for configuration**
   ```csharp
   // ✅ CORRECT - Interface in Application
   public interface IYourSettings
   {
       string SomeProperty { get; }
   }
   
   // ✅ CORRECT - Implementation in Infrastructure
   public class YourSettings : IYourSettings
   {
       public const string Key = "YourSection";
       public string SomeProperty { get; set; } = string.Empty;
   }
   ```

2. **NEVER inject IConfiguration directly in UI layer**
   ```csharp
   // ❌ WRONG
   @inject IConfiguration Config
   
   // ✅ CORRECT
   @inject IYourSettings Settings
   ```

### **Permission Management Rules**
1. **ALWAYS define permissions in Application.Common.Security**
   ```csharp
   // ✅ CORRECT - in Application/Common/Security/Permissions/
   public static class YourModulePermissions
   {
       public const string View = "Permissions.YourModule.View";
       public const string Create = "Permissions.YourModule.Create";
   }
   ```

2. **ALWAYS use IPermissionService for permission checks**
   ```csharp
   // ✅ CORRECT
   @inject IPermissionService PermissionService
   var hasPermission = await PermissionService.HasPermissionAsync(Permissions.Users.View);
   
   // ❌ WRONG - Direct authorization
   @inject IAuthorizationService AuthService
   ```

### **Constants and Enums Rules**
1. **ALWAYS place constants in Application.Common.Constants**
   ```csharp
   // ✅ CORRECT - Application/Common/Constants/
   public static class YourConstants
   {
       public const string SomeValue = "value";
   }
   
   // ❌ WRONG - Constants in Infrastructure or UI
   ```

2. **AVOID magic strings - use constants instead**
   ```csharp
   // ❌ WRONG
   var claim = "Permissions.Users.View";
   
   // ✅ CORRECT  
   var claim = Permissions.Users.View;
   ```

## 🎯 **BLAZOR SPECIFIC RULES**

### **Component Injection Rules**
```csharp
// ✅ ALWAYS use these standard injections in _Imports.razor
@inject IApplicationSettings ApplicationSettings
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IAuthorizationService AuthService
@inject IValidationService Validator
@inject IJSRuntime JS
@inject IMediator Mediator
@inject NavigationManager Navigation
@inject IPermissionService PermissionService
@inject IMapper Mapper

// ❌ NEVER inject these in UI
@inject ApplicationDbContext
@inject IConfiguration
```

### **Component Structure Rules**
1. **Group related components in feature folders**
   ```
   Pages/
   ├── Products/
   │   ├── Products.razor
   │   └── Components/
   │       ├── ProductForm.razor
   │       └── ProductList.razor
   ```

2. **Use proper authorization attributes**
   ```csharp
   @attribute [Authorize(Policy = Permissions.Products.View)]
   ```

## 📦 **DEPENDENCY INJECTION RULES**

### **Service Registration Patterns**
```csharp
// ✅ Application Layer (Application/DependencyInjection.cs)
services.AddMediatR(config => { /* MediatR setup */ });
services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

// ✅ Infrastructure Layer (Infrastructure/DependencyInjection.cs)  
services.AddScoped<IUserService, UserService>();
services.Configure<DatabaseSettings>(config.GetSection("DatabaseSettings"));

// ✅ UI Layer (Server.UI/DependencyInjection.cs)
services.AddScoped<IPermissionHelper, PermissionHelper>();
services.AddMudServices();
```

### **Interface Registration Rules**
```csharp
// ✅ ALWAYS register both interface and implementation
services.AddScoped<IYourService, YourService>();

// ✅ For configuration classes
services.Configure<YourSettings>(config.GetSection(YourSettings.Key))
    .AddSingleton<IYourSettings>(s => s.GetRequiredService<IOptions<YourSettings>>().Value);
```

## 🔍 **CODE QUALITY RULES**

### **Naming Conventions**
1. **Interfaces**: Start with 'I' (IUserService)
2. **DTOs**: End with 'Dto' (UserDto)  
3. **Commands**: End with 'Command' (CreateUserCommand)
4. **Queries**: End with 'Query' (GetUsersQuery)
5. **Validators**: End with 'Validator' (CreateUserCommandValidator)
6. **Specifications**: End with 'Specification' (UserActiveSpecification)

### **File Organization**
```csharp
// ✅ Feature-based organization in Application layer
Application/
├── Features/
│   └── Users/
│       ├── Commands/
│       ├── Queries/
│       ├── DTOs/
│       ├── Specifications/
│       └── Caching/
```

### **Error Handling**
```csharp
// ✅ ALWAYS use Result pattern
public async Task<Result<UserDto>> GetUserAsync(string id)
{
    try 
    {
        // implementation
        return Result<UserDto>.Success(userDto);
    }
    catch (Exception ex)
    {
        return Result<UserDto>.Failure($"Error: {ex.Message}");
    }
}
```

## 🚫 **ANTI-PATTERNS TO AVOID**

### **Architecture Violations**
```csharp
// ❌ NEVER do these
using Infrastructure.Services;           // in UI layer
using Infrastructure.Persistence;        // in UI layer  
using Infrastructure.Configurations;     // in UI layer
using Server.UI.Services;               // in Application layer
```

### **Direct Database Access**
```csharp
// ❌ NEVER in UI components
@inject ApplicationDbContext Context
var users = await Context.Users.ToListAsync();

// ✅ ALWAYS use CQRS
var result = await Mediator.Send(new GetUsersQuery());
```

### **Configuration Anti-patterns**
```csharp
// ❌ NEVER access config directly in UI
@inject IConfiguration Config
var value = Config["SomeSection:SomeKey"];

// ✅ ALWAYS use typed settings
@inject ISomeSettings Settings  
var value = Settings.SomeProperty;
```

## 🎨 **UI/UX GUIDELINES**

### **MudBlazor Standards**
```csharp
// ✅ Standard MudBlazor patterns
<MudDataGrid ServerData="ServerReload" 
             FixedHeader="true"
             Loading="@_loading"
             MultiSelection="true" />

// ✅ Consistent snackbar usage
Snackbar.Add(L["Success message"], Severity.Success);
```

### **Localization Rules**
```csharp
// ✅ ALWAYS use IStringLocalizer
@inject IStringLocalizer<YourComponent> L
<MudText>@L["Your localized text"]</MudText>

// ❌ NEVER hardcode text
<MudText>Hardcoded English text</MudText>
```

## 📝 **DOCUMENTATION STANDARDS**

### **XML Documentation**
```csharp
/// <summary>
/// Brief description of what this method does.
/// </summary>
/// <param name="parameter">Parameter description.</param>
/// <returns>Return value description.</returns>
public async Task<Result<T>> MethodAsync(ParameterType parameter)
```

### **Comments for Complex Logic**
```csharp
// Explain WHY, not WHAT
// We use reflection here to automatically map permissions to AccessRights properties
// based on naming conventions (e.g., "Create" property maps to "Permissions.Module.Create")
```

## 🔒 **SECURITY GUIDELINES**

### **Authorization Patterns**
```csharp
// ✅ Page-level authorization
@attribute [Authorize(Policy = Permissions.Users.View)]

// ✅ Conditional rendering based on permissions
@if (await PermissionService.HasPermissionAsync(Permissions.Users.Create))
{
    <MudButton>Create User</MudButton>
}
```

### **Input Validation**
```csharp
// ✅ ALWAYS use FluentValidation
public class CreateUserCommandValidator : AbstractValidator<CreateUserCommand>
{
    public CreateUserCommandValidator()
    {
        RuleFor(x => x.Email).NotEmpty().EmailAddress();
    }
}
```

## 🚀 **PERFORMANCE CONSIDERATIONS**

### **Caching Patterns**
```csharp
// ✅ Use FusionCache for performance
[FusionCacheEvict(GlobalCacheKeys.GetCacheKey<User>())]
public class DeleteUserCommand : IRequest<Result<int>>
```

### **Query Optimization**
```csharp
// ✅ Use ProjectTo for efficient queries
return await query.ProjectTo<UserDto>(_mapper.ConfigurationProvider)
                 .ToListAsync(cancellationToken);
```

## 📊 **TESTING GUIDELINES**

### **Unit Test Structure**
```csharp
// ✅ Arrange-Act-Assert pattern
[Test]
public async Task Handle_ValidCommand_ShouldCreateUser()
{
    // Arrange
    var command = new CreateUserCommand { /* properties */ };
    
    // Act  
    var result = await _handler.Handle(command, CancellationToken.None);
    
    // Assert
    result.Succeeded.Should().BeTrue();
}
```

---

## 📋 **BEFORE EVERY COMMIT CHECKLIST**

- [ ] No direct dependencies from UI to Infrastructure (except Program.cs)
- [ ] All services have interfaces in Application layer
- [ ] No direct DbContext access in UI components
- [ ] No direct IConfiguration injection in UI
- [ ] All constants are in Application.Common.Constants
- [ ] All permissions are in Application.Common.Security
- [ ] Proper error handling with Result pattern
- [ ] XML documentation for public APIs
- [ ] Unit tests for new business logic
- [ ] Authorization attributes on new pages/components

## 🎯 **CONTEXT ENGINEERING BEST PRACTICES**

When working with Cursor AI, always:
1. **Reference the specific layer** you're working in
2. **Mention the pattern** you want to follow (CQRS, Repository, etc.)
3. **Specify the interfaces** that need to be implemented
4. **Include the namespace structure** in your requests
5. **Ask for the complete implementation** including registration in DI container

Example prompt: "Create a new IProductService interface in Application layer following CQRS pattern, with corresponding ProductService implementation in Infrastructure layer, and register it in Infrastructure.DependencyInjection."
